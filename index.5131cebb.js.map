{"mappings":"AGiJA,SAAS,cAAc,CAAC,aAAa,gBAAgB,CAAC,SAEtD,SAAoB,CAAK,EACvB,IAAM,EAAO,EAAM,MAAM,CAAC,KAAK,CAAC,EAAE,CAClC,GAAI,CAAC,EAAM,CACT,MAAM,8BACN,MACF,CAEA,IAAM,EAAS,IAAI,UACnB,CAAA,EAAO,MAAM,CAAG,SAAU,CAAC,EAUzB,QAAQ,GAAG,CAAC,SAFG,AAwGnB,SAAsB,CAAO,EAC3B,IAAM,EAAQ,AAgChB,SAAoB,CAAO,EACzB,IAAM,EAAQ,CAAC,EAQf,OAPA,EAAQ,OAAO,CAAC,AAAA,IACd,IAAM,EAAS,EAAI,KAAK,CAAC,GACpB,CAAA,CAAK,CAAC,EAAO,EAChB,CAAA,CAAK,CAAC,EAAO,CAAG,EAAE,AAAF,EAElB,CAAK,CAAC,EAAO,CAAC,IAAI,CAAC,EACrB,GACO,CACT,EA1C2B,GACzB,QAAQ,GAAG,CAAC,QAAS,GAErB,IAAI,EAAe,EAAE,CAyBrB,OAtBA,EAAQ,OAAO,CAAC,AAAA,IACd,IAAM,EAAQ,CAAC,CAAC,EAAO,CAAC,EAAM,CAAC,CAAC,CAEhC,KAAO,EAAM,MAAM,CAAG,GAAG,CACvB,GAAM,CAAC,EAAS,EAAM,CAAG,EAAM,GAAG,GAE5B,EAAc,CAAK,CADV,EAAQ,KAAK,CAAC,IACI,EAAI,EAAE,AAGnC,CAAA,EAAM,MAAM,CAAG,EAAa,MAAM,EACpC,CAAA,EAAe,CADjB,EAIA,EAAY,OAAO,CAAC,AAAA,IACb,EAAM,QAAQ,CAAC,IAElB,EAAM,IAAI,CAAC,CAAC,EAAS,IAAI,EAAO,EAAQ,CAAC,CAE7C,EACF,CACF,GAEO,CACT,EA5IoB,AADA,EAAE,MAAM,CAAC,MAAM,CAE5B,KAAK,CAAC,UACN,MAAM,CAAC,SACP,MAAM,CAAC,AAAA,GAAO,QAAQ,IAAI,CAAC,KAQhC,EACA,EAAO,UAAU,CAAC,EACpB","sources":["<anon>","src/index.js","src/scripts/index.js","src/scripts/numbers.js"],"sourcesContent":["(function () {\n// const numbers = [\n//   '942517',\n//   '605676',\n//   '498291',\n//   '668826',\n//   '357057',\n//   '478151',\n//   '315629',\n//   '007148',\n//   '252887',\n//   '421662',\n//   '284505',\n//   '467650',\n//   '115330',\n//   '648206',\n//   '207562',\n//   '612298',\n//   '576885',\n//   '294200',\n//   '847595',\n//   '021597',\n//   '074878',\n//   '801997',\n//   '585401',\n//   '168510',\n//   '385293',\n//   '151863',\n//   '022142',\n//   '340350',\n//   '976151',\n//   '337989',\n//   '863284',\n//   '488310',\n//   '303887',\n//   '939173',\n//   '331413',\n//   '905657',\n//   '833617',\n//   '170794',\n//   '094486',\n//   '551394',\n//   '943693',\n//   '147970',\n//   '400196',\n//   '537505',\n//   '367493',\n//   '117178',\n//   '675840',\n//   '868721',\n//   '519081',\n//   '735564',\n//   '401733',\n//   '915348',\n//   '169233',\n//   '324651',\n//   '958675',\n//   '368753',\n//   '861460',\n//   '401341',\n//   '343222',\n//   '794373',\n//   '816374',\n//   '535119',\n//   '188234',\n//   '577779',\n//   '097792',\n//   '729303',\n//   '782637',\n//   '148159',\n//   '830641',\n//   '716890',\n//   '397853',\n//   '871196',\n//   '277603',\n//   '749226',\n//   '839595',\n//   '131852',\n//   '409432',\n//   '810698',\n//   '456030',\n//   '529185',\n//   '758823',\n//   '265024',\n//   '051041',\n//   '699031',\n//   '737269',\n//   '139340',\n//   '730977',\n//   '249786',\n//   '039931',\n//   '055669',\n//   '100107',\n//   '653178',\n//   '279773',\n//   '336550',\n//   '332847',\n//   '685485',\n//   '423269',\n//   '193536',\n//   '890062',\n//   '377637',\n//   '595777',\n//   '412134',\n//   '322736',\n//   '546929',\n//   '616370',\n//   '767332',\n//   '781184',\n//   '920944',\n//   '851005',\n//   '258850',\n//   '064083',\n//   '051202',\n//   '427711',\n//   '359855',\n//   '540928',\n//   '314284',\n//   '085261',\n//   '880969',\n//   '649699',\n//   '064881',\n//   '705423',\n//   '646927',\n//   '252556',\n//   '272007',\n//   '217511',\n//   '620286',\n//   '229724',\n//   '108865',\n//   '124636',\n//   '231417',\n//   '961201',\n//   '658432',\n//   '775416',\n//   '246027',\n//   '854036',\n//   '687762',\n//   '389097',\n//   '013153',\n//   '417085',\n//   '919198',\n//   '988711',\n//   '488665',\n// ];\ndocument.getElementById('fileInput').addEventListener('change', $52ffb9f4c07b01a1$var$handleFile);\nfunction $52ffb9f4c07b01a1$var$handleFile(event) {\n    const file = event.target.files[0];\n    if (!file) {\n        alert(\"\\u0411\\u0443\\u0434\\u044C \\u043B\\u0430\\u0441\\u043A\\u0430, \\u0432\\u0438\\u0431\\u0435\\u0440\\u0456\\u0442\\u044C \\u0444\\u0430\\u0439\\u043B.\");\n        return;\n    }\n    const reader = new FileReader();\n    reader.onload = function(e) {\n        const content = e.target.result;\n        const numbers = content.split(/[\\s,]+/).filter(Boolean).filter((str)=>/^\\d+$/.test(str));\n        // console.log('numbers', numbers);\n        const result = $52ffb9f4c07b01a1$var$dfsWithStack(numbers);\n        console.log('result', result);\n    // document.getElementById('result').textContent = `Результат: ${result}`;\n    };\n    reader.readAsText(file);\n}\n// function solvePuzzle(numbers) {\n//   // Створити граф, де вершинами є числа, а ребрами — можливі переходи (за правилами пазлу).\n//   const edges = new Map();\n//   for (const num1 of numbers) {\n//     // Отримуємо суфікс поточного числа\n//     const suffix = num1.slice(-2);\n//     for (const num2 of numbers) {\n//       // Отримуємо префікс іншого числа\n//       const prefix = num2.slice(0, 2);\n//       // Додаємо ребро, якщо суфікс дорівнює префіксу\n//       if (suffix === prefix && num1 !== num2) {\n//         if (!edges.has(num1)) {\n//           edges.set(num1, []);\n//         }\n//         edges.get(num1).push(num2);\n//       }\n//     }\n//   }\n//   console.log('map', edges);\n// }\n// function findStartingNumbers(numbers) {\n//   const prefixes = numbers.map(num => num.slice(0, 2)); // Перші дві цифри\n//   const suffixes = numbers.map(num => num.slice(-2)); // Останні дві цифри\n//   // Знайдемо числа, у яких перші дві цифри не збігаються з жодним суфіксом\n//   const startingNumbers = numbers.filter((num, index) => {\n//     const prefix = prefixes[index];\n//     return !suffixes.some((suffix, i) => suffix === prefix && i !== index);\n//   });\n//   return startingNumbers;\n// }\nfunction $52ffb9f4c07b01a1$var$solvePuzzle(numbers) {\n    const graph = new Map();\n    const memo = new Map(); // Для збереження результатів\n    const maxDepth = 150; // Обмеження на максимальну глибину BFS\n    // Побудова графа\n    for (const num of numbers){\n        const suffix = num.slice(-2);\n        if (!graph.has(suffix)) graph.set(suffix, []);\n        graph.get(suffix).push(num);\n    }\n    // BFS з обмеженням глибини\n    function findLongestChainBFS(start) {\n        if (memo.has(start)) return memo.get(start);\n        const queue = [\n            [\n                start,\n                [\n                    start\n                ]\n            ]\n        ];\n        let longestChain = [];\n        while(queue.length > 0){\n            const [current, chain] = queue.shift();\n            const suffix = current.slice(-2);\n            const nextNumbers = graph.get(suffix) || [];\n            // Оновлення найдовшого ланцюжка\n            if (chain.join('').length > longestChain.join('').length) longestChain = chain;\n            // Якщо досягли максимального рівня глибини, припиняємо пошук\n            if (chain.length >= maxDepth) continue;\n            for (const next of nextNumbers)if (!chain.includes(next)) // Уникаємо циклів\n            queue.push([\n                next,\n                [\n                    ...chain,\n                    next\n                ]\n            ]);\n        }\n        // Збереження результату в мемо\n        memo.set(start, longestChain);\n        return longestChain;\n    }\n    // Перевірка всіх стартових чисел\n    let longestChainOverall = [];\n    for (const start of numbers){\n        const chain = findLongestChainBFS(start);\n        if (chain.join('').length > longestChainOverall.join('').length) longestChainOverall = chain;\n    }\n    return longestChainOverall.join('');\n}\nfunction $52ffb9f4c07b01a1$var$dfsWithStack(numbers) {\n    const graph = $52ffb9f4c07b01a1$var$buildGraph(numbers); // Побудова графа\n    console.log('graph', graph);\n    let longestChain = []; // Найдовший ланцюжок\n    // Ітеративний DFS для кожного стартового числа\n    numbers.forEach((start)=>{\n        const stack = [\n            [\n                start,\n                [\n                    start\n                ]\n            ]\n        ]; // Стек: [поточне число, поточний ланцюжок]\n        while(stack.length > 0){\n            const [current, chain] = stack.pop();\n            const suffix = current.slice(-2); // Останні дві цифри\n            const nextNumbers = graph[suffix] || [];\n            // Якщо цей шлях довший за поточний найдовший, оновлюємо його\n            if (chain.length > longestChain.length) longestChain = chain;\n            nextNumbers.forEach((nextNum)=>{\n                if (!chain.includes(nextNum)) // Уникнення циклів\n                stack.push([\n                    nextNum,\n                    [\n                        ...chain,\n                        nextNum\n                    ]\n                ]);\n            });\n        }\n    });\n    return longestChain;\n}\n// Функція для побудови графа\nfunction $52ffb9f4c07b01a1$var$buildGraph(numbers) {\n    const graph = {};\n    numbers.forEach((num)=>{\n        const suffix = num.slice(-2); // Останні дві цифри\n        if (!graph[suffix]) graph[suffix] = [];\n        graph[suffix].push(num);\n    });\n    return graph;\n}\n\n\n\n\n\n})();\n//# sourceMappingURL=index.5131cebb.js.map\n","import './scripts';\n","import './numbers';\n","// const numbers = [\n//   '942517',\n//   '605676',\n//   '498291',\n//   '668826',\n//   '357057',\n//   '478151',\n//   '315629',\n//   '007148',\n//   '252887',\n//   '421662',\n//   '284505',\n//   '467650',\n//   '115330',\n//   '648206',\n//   '207562',\n//   '612298',\n//   '576885',\n//   '294200',\n//   '847595',\n//   '021597',\n//   '074878',\n//   '801997',\n//   '585401',\n//   '168510',\n//   '385293',\n//   '151863',\n//   '022142',\n//   '340350',\n//   '976151',\n//   '337989',\n//   '863284',\n//   '488310',\n//   '303887',\n//   '939173',\n//   '331413',\n//   '905657',\n//   '833617',\n//   '170794',\n//   '094486',\n//   '551394',\n//   '943693',\n//   '147970',\n//   '400196',\n//   '537505',\n//   '367493',\n//   '117178',\n//   '675840',\n//   '868721',\n//   '519081',\n//   '735564',\n//   '401733',\n//   '915348',\n//   '169233',\n//   '324651',\n//   '958675',\n//   '368753',\n//   '861460',\n//   '401341',\n//   '343222',\n//   '794373',\n//   '816374',\n//   '535119',\n//   '188234',\n//   '577779',\n//   '097792',\n//   '729303',\n//   '782637',\n//   '148159',\n//   '830641',\n//   '716890',\n//   '397853',\n//   '871196',\n//   '277603',\n//   '749226',\n//   '839595',\n//   '131852',\n//   '409432',\n//   '810698',\n//   '456030',\n//   '529185',\n//   '758823',\n//   '265024',\n//   '051041',\n//   '699031',\n//   '737269',\n//   '139340',\n//   '730977',\n//   '249786',\n//   '039931',\n//   '055669',\n//   '100107',\n//   '653178',\n//   '279773',\n//   '336550',\n//   '332847',\n//   '685485',\n//   '423269',\n//   '193536',\n//   '890062',\n//   '377637',\n//   '595777',\n//   '412134',\n//   '322736',\n//   '546929',\n//   '616370',\n//   '767332',\n//   '781184',\n//   '920944',\n//   '851005',\n//   '258850',\n//   '064083',\n//   '051202',\n//   '427711',\n//   '359855',\n//   '540928',\n//   '314284',\n//   '085261',\n//   '880969',\n//   '649699',\n//   '064881',\n//   '705423',\n//   '646927',\n//   '252556',\n//   '272007',\n//   '217511',\n//   '620286',\n//   '229724',\n//   '108865',\n//   '124636',\n//   '231417',\n//   '961201',\n//   '658432',\n//   '775416',\n//   '246027',\n//   '854036',\n//   '687762',\n//   '389097',\n//   '013153',\n//   '417085',\n//   '919198',\n//   '988711',\n//   '488665',\n// ];\n\ndocument.getElementById('fileInput').addEventListener('change', handleFile);\n\nfunction handleFile(event) {\n  const file = event.target.files[0];\n  if (!file) {\n    alert('Будь ласка, виберіть файл.');\n    return;\n  }\n\n  const reader = new FileReader();\n  reader.onload = function (e) {\n    const content = e.target.result;\n    const numbers = content\n      .split(/[\\s,]+/)\n      .filter(Boolean)\n      .filter(str => /^\\d+$/.test(str));\n    // console.log('numbers', numbers);\n\n    const result = dfsWithStack(numbers);\n\n    console.log('result', result);\n\n    // document.getElementById('result').textContent = `Результат: ${result}`;\n  };\n  reader.readAsText(file);\n}\n\n// function solvePuzzle(numbers) {\n//   // Створити граф, де вершинами є числа, а ребрами — можливі переходи (за правилами пазлу).\n//   const edges = new Map();\n//   for (const num1 of numbers) {\n//     // Отримуємо суфікс поточного числа\n//     const suffix = num1.slice(-2);\n\n//     for (const num2 of numbers) {\n//       // Отримуємо префікс іншого числа\n//       const prefix = num2.slice(0, 2);\n\n//       // Додаємо ребро, якщо суфікс дорівнює префіксу\n//       if (suffix === prefix && num1 !== num2) {\n//         if (!edges.has(num1)) {\n//           edges.set(num1, []);\n//         }\n//         edges.get(num1).push(num2);\n//       }\n//     }\n//   }\n//   console.log('map', edges);\n// }\n\n// function findStartingNumbers(numbers) {\n//   const prefixes = numbers.map(num => num.slice(0, 2)); // Перші дві цифри\n//   const suffixes = numbers.map(num => num.slice(-2)); // Останні дві цифри\n\n//   // Знайдемо числа, у яких перші дві цифри не збігаються з жодним суфіксом\n//   const startingNumbers = numbers.filter((num, index) => {\n//     const prefix = prefixes[index];\n//     return !suffixes.some((suffix, i) => suffix === prefix && i !== index);\n//   });\n\n//   return startingNumbers;\n// }\n\nfunction solvePuzzle(numbers) {\n  const graph = new Map();\n  const memo = new Map(); // Для збереження результатів\n  const maxDepth = 150; // Обмеження на максимальну глибину BFS\n\n  // Побудова графа\n  for (const num of numbers) {\n    const suffix = num.slice(-2);\n    if (!graph.has(suffix)) {\n      graph.set(suffix, []);\n    }\n    graph.get(suffix).push(num);\n  }\n\n  // BFS з обмеженням глибини\n  function findLongestChainBFS(start) {\n    if (memo.has(start)) return memo.get(start);\n\n    const queue = [[start, [start]]];\n    let longestChain = [];\n\n    while (queue.length > 0) {\n      const [current, chain] = queue.shift();\n      const suffix = current.slice(-2);\n      const nextNumbers = graph.get(suffix) || [];\n\n      // Оновлення найдовшого ланцюжка\n      if (chain.join('').length > longestChain.join('').length) {\n        longestChain = chain;\n      }\n\n      // Якщо досягли максимального рівня глибини, припиняємо пошук\n      if (chain.length >= maxDepth) continue;\n\n      for (const next of nextNumbers) {\n        if (!chain.includes(next)) {\n          // Уникаємо циклів\n          queue.push([next, [...chain, next]]);\n        }\n      }\n    }\n\n    // Збереження результату в мемо\n    memo.set(start, longestChain);\n    return longestChain;\n  }\n\n  // Перевірка всіх стартових чисел\n  let longestChainOverall = [];\n  for (const start of numbers) {\n    const chain = findLongestChainBFS(start);\n    if (chain.join('').length > longestChainOverall.join('').length) {\n      longestChainOverall = chain;\n    }\n  }\n\n  return longestChainOverall.join('');\n}\n\nfunction dfsWithStack(numbers) {\n  const graph = buildGraph(numbers); // Побудова графа\n  console.log('graph', graph);\n\n  let longestChain = []; // Найдовший ланцюжок\n\n  // Ітеративний DFS для кожного стартового числа\n  numbers.forEach(start => {\n    const stack = [[start, [start]]]; // Стек: [поточне число, поточний ланцюжок]\n\n    while (stack.length > 0) {\n      const [current, chain] = stack.pop();\n      const suffix = current.slice(-2); // Останні дві цифри\n      const nextNumbers = graph[suffix] || [];\n\n      // Якщо цей шлях довший за поточний найдовший, оновлюємо його\n      if (chain.length > longestChain.length) {\n        longestChain = chain;\n      }\n\n      nextNumbers.forEach(nextNum => {\n        if (!chain.includes(nextNum)) {\n          // Уникнення циклів\n          stack.push([nextNum, [...chain, nextNum]]);\n        }\n      });\n    }\n  });\n\n  return longestChain;\n}\n\n// Функція для побудови графа\nfunction buildGraph(numbers) {\n  const graph = {};\n  numbers.forEach(num => {\n    const suffix = num.slice(-2); // Останні дві цифри\n    if (!graph[suffix]) {\n      graph[suffix] = [];\n    }\n    graph[suffix].push(num);\n  });\n  return graph;\n}\n"],"names":["document","getElementById","addEventListener","event","file","target","files","alert","reader","FileReader","onload","e","console","log","$52ffb9f4c07b01a1$var$dfsWithStack","numbers","graph","$52ffb9f4c07b01a1$var$buildGraph","forEach","num","suffix","slice","push","longestChain","start","stack","length","current","chain","pop","nextNumbers","nextNum","includes","content","result","split","filter","Boolean","str","test","readAsText"],"version":3,"file":"index.5131cebb.js.map"}